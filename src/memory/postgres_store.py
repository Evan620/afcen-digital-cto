"""PostgreSQL-based episodic memory for the Digital CTO.

Stores long-term records: PR review logs, agent decisions, and audit trails.
Uses SQLAlchemy async with asyncpg.
"""

from __future__ import annotations

import logging
from datetime import datetime

from sqlalchemy import Column, DateTime, Integer, String, Text, JSON, Enum as SAEnum, Float, Boolean, func
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.sql import select

from src.config import settings

logger = logging.getLogger(__name__)


# ── ORM Base ──


class Base(DeclarativeBase):
    """SQLAlchemy declarative base for all tables."""
    pass


# ── Tables ──


class ReviewLog(Base):
    """Log of every PR review performed by the Code Review agent."""

    __tablename__ = "review_logs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    repository = Column(String(255), nullable=False, index=True)
    pr_number = Column(Integer, nullable=False)
    pr_title = Column(String(500), nullable=False)
    pr_author = Column(String(100), nullable=False)
    verdict = Column(String(50), nullable=False)  # APPROVE, REQUEST_CHANGES, COMMENT
    summary = Column(Text, nullable=False)
    comments_json = Column(JSON, default=list)
    security_issues = Column(JSON, default=list)
    deprecated_deps = Column(JSON, default=list)
    reviewed_at = Column(DateTime, default=func.now(), nullable=False)
    created_at = Column(DateTime, default=func.now(), nullable=False)


class AgentDecision(Base):
    """Log of significant decisions made by any agent for audit trail."""

    __tablename__ = "agent_decisions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    agent_name = Column(String(100), nullable=False, index=True)
    decision_type = Column(String(100), nullable=False)
    context = Column(JSON, default=dict)
    reasoning = Column(Text, nullable=False)
    outcome = Column(Text, nullable=False)
    created_at = Column(DateTime, default=func.now(), nullable=False)


class PREvent(Base):
    """Raw PR webhook events for replay and debugging."""

    __tablename__ = "pr_events"

    id = Column(Integer, primary_key=True, autoincrement=True)
    repository = Column(String(255), nullable=False, index=True)
    pr_number = Column(Integer, nullable=False)
    action = Column(String(50), nullable=False)
    payload = Column(JSON, nullable=False)
    received_at = Column(DateTime, default=func.now(), nullable=False)


class ScheduledReport(Base):
    """Scheduled reports generated by the APScheduler automation."""

    __tablename__ = "scheduled_reports"

    id = Column(Integer, primary_key=True, autoincrement=True)
    report_type = Column(String(50), nullable=False, index=True)  # daily_standup, weekly_report, bayes_alert, morning_brief, market_scan
    report_data = Column(JSON, nullable=False)
    generated_at = Column(DateTime, default=func.now(), nullable=False)
    notified = Column(String(10), default="no")  # yes/no — whether JARVIS was notified


# ── Phase 3 Tables ──


class MarketIntel(Base):
    """Market intelligence collected from various sources."""

    __tablename__ = "market_intel"

    id = Column(Integer, primary_key=True, autoincrement=True)
    source = Column(String(50), nullable=False, index=True)  # news, dfi_opportunity, carbon_market, etc.
    source_name = Column(String(100), nullable=False)  # e.g., "Feedly", "World Bank API"
    title = Column(String(500), nullable=False)
    summary = Column(Text, nullable=False)
    url = Column(String(1000))
    published_at = Column(DateTime, nullable=True)
    collected_at = Column(DateTime, default=func.now(), nullable=False, index=True)
    relevance_score = Column(Float, default=0.5, index=True)

    # Categorization
    tags = Column(JSON, default=list)  # List of tag strings
    region = Column(String(100))
    sector = Column(String(100))

    # Content extraction
    key_points = Column(JSON, default=list)
    organizations = Column(JSON, default=list)
    mentioned_technologies = Column(JSON, default=list)

    # Raw data and deduplication
    raw_data = Column(JSON, default=dict)
    content_hash = Column(String(32), unique=True, index=True)  # For deduplication


class MorningBriefRecord(Base):
    """Morning brief records for archival and analysis."""

    __tablename__ = "morning_briefs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    brief_id = Column(String(50), unique=True, nullable=False, index=True)  # e.g., "brief_20260225"
    brief_date = Column(DateTime, nullable=False, index=True)
    brief_data = Column(JSON, nullable=False)  # Full brief structure
    generated_at = Column(DateTime, default=func.now(), nullable=False)
    delivered = Column(Boolean, default=False)
    delivery_time = Column(DateTime)


class MeetingRecord(Base):
    """Meeting records and transcripts."""

    __tablename__ = "meetings"

    id = Column(Integer, primary_key=True, autoincrement=True)
    meeting_id = Column(String(100), unique=True, nullable=False, index=True)
    title = Column(String(500), nullable=False)
    meeting_date = Column(DateTime, nullable=False)
    participants = Column(JSON, default=list)  # List of participant names
    duration_minutes = Column(Integer)
    meeting_type = Column(String(100))  # e.g., "Weekly Team Meeting", "Energy TWG"

    # Recall.ai integration
    recall_bot_id = Column(String(100))
    recall_transcript_id = Column(String(100))

    created_at = Column(DateTime, default=func.now(), nullable=False)


class MeetingTranscript(Base):
    """Meeting transcripts with semantic search support."""

    __tablename__ = "meeting_transcripts"

    id = Column(Integer, primary_key=True, autoincrement=True)
    meeting_id = Column(String(100), nullable=False, index=True)  # FK to meetings
    transcript_text = Column(Text, nullable=False)
    raw_transcript = Column(JSON)  # Full raw data from Recall.ai/AssemblyAI
    speaker_labels = Column(Boolean, default=True)  # Whether speakers are identified
    collected_at = Column(DateTime, default=func.now(), nullable=False)


class MeetingDecision(Base):
    """Decisions made in meetings."""

    __tablename__ = "meeting_decisions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    meeting_id = Column(String(100), nullable=False, index=True)
    decision = Column(Text, nullable=False)
    decision_maker = Column(String(200))  # Who made the decision
    context = Column(Text)  # Additional context
    impact = Column(Text)  # Expected impact
    created_at = Column(DateTime, default=func.now(), nullable=False)


class ActionItem(Base):
    """Action items from meetings or briefs."""

    __tablename__ = "action_items"

    id = Column(Integer, primary_key=True, autoincrement=True)
    meeting_id = Column(String(100), index=True)  # Optional: linked to meeting
    brief_id = Column(String(50), index=True)  # Optional: linked to brief
    task = Column(Text, nullable=False)
    owner = Column(String(200), nullable=False)
    due_date = Column(DateTime)
    priority = Column(String(20), default="medium")  # low, medium, high, urgent
    status = Column(String(50), default="pending")  # pending, in_progress, complete, cancelled
    created_at = Column(DateTime, default=func.now(), nullable=False)
    completed_at = Column(DateTime)


# ── Store Class ──


class PostgresStore:
    """Async PostgreSQL client for episodic memory."""

    def __init__(self, url: str | None = None) -> None:
        self._url = url or settings.postgres_url
        self._engine = create_async_engine(self._url, echo=False, pool_size=10, max_overflow=20)
        self._session_factory = async_sessionmaker(self._engine, expire_on_commit=False)

    async def init_db(self) -> None:
        """Create all tables if they don't exist."""
        async with self._engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        logger.info("PostgreSQL episodic memory initialized")

    async def disconnect(self) -> None:
        """Dispose of the engine connection pool."""
        await self._engine.dispose()
        logger.info("PostgreSQL connection closed")

    def session(self) -> AsyncSession:
        """Get a new async session."""
        return self._session_factory()

    # ── Review Logs ──

    async def log_review(
        self,
        repository: str,
        pr_number: int,
        pr_title: str,
        pr_author: str,
        verdict: str,
        summary: str,
        comments: list[dict] | None = None,
        security_issues: list[str] | None = None,
        deprecated_deps: list[str] | None = None,
    ) -> int:
        """Persist a code review result and return the log ID."""
        async with self.session() as session:
            log = ReviewLog(
                repository=repository,
                pr_number=pr_number,
                pr_title=pr_title,
                pr_author=pr_author,
                verdict=verdict,
                summary=summary,
                comments_json=comments or [],
                security_issues=security_issues or [],
                deprecated_deps=deprecated_deps or [],
                reviewed_at=datetime.utcnow(),
            )
            session.add(log)
            await session.commit()
            await session.refresh(log)
            logger.info("Review logged: %s PR #%d → %s (id=%d)", repository, pr_number, verdict, log.id)
            return log.id

    async def log_event(self, repository: str, pr_number: int, action: str, payload: dict) -> None:
        """Store a raw PR webhook event for replay/debugging."""
        async with self.session() as session:
            event = PREvent(
                repository=repository,
                pr_number=pr_number,
                action=action,
                payload=payload,
            )
            session.add(event)
            await session.commit()

    async def log_decision(
        self, agent_name: str, decision_type: str, reasoning: str, outcome: str, context: dict | None = None
    ) -> None:
        """Store a significant agent decision for audit trail."""
        async with self.session() as session:
            decision = AgentDecision(
                agent_name=agent_name,
                decision_type=decision_type,
                context=context or {},
                reasoning=reasoning,
                outcome=outcome,
            )
            session.add(decision)
            await session.commit()

        # Phase 4: Also log to knowledge graph if enabled
        if settings.knowledge_graph_enabled:
            try:
                from src.memory.knowledge_graph import KnowledgeGraphStore

                kg = KnowledgeGraphStore()
                await kg.log_decision_to_graph(
                    agent_name=agent_name,
                    decision_type=decision_type,
                    reasoning=reasoning,
                    outcome=outcome,
                    context=context or {},
                )
            except Exception as e:
                logger.debug("Knowledge graph logging failed: %s", e)

    # ── Scheduled Reports ──

    async def save_report(
        self, report_type: str, report_data: dict, notified: bool = False
    ) -> int:
        """Persist a scheduled report and return the report ID."""
        async with self.session() as session:
            report = ScheduledReport(
                report_type=report_type,
                report_data=report_data,
                notified="yes" if notified else "no",
            )
            session.add(report)
            await session.commit()
            await session.refresh(report)
            logger.info("Saved %s report (id=%d)", report_type, report.id)
            return report.id

    async def get_recent_reports(self, report_type: str | None = None, limit: int = 10) -> list[dict]:
        """Fetch recent scheduled reports, optionally filtered by type."""
        from sqlalchemy import select

        async with self.session() as session:
            stmt = select(ScheduledReport).order_by(ScheduledReport.generated_at.desc()).limit(limit)
            if report_type:
                stmt = stmt.where(ScheduledReport.report_type == report_type)
            result = await session.execute(stmt)
            rows = result.scalars().all()
            return [
                {
                    "id": r.id,
                    "report_type": r.report_type,
                    "report_data": r.report_data,
                    "generated_at": r.generated_at.isoformat() if r.generated_at else None,
                    "notified": r.notified,
                }
                for r in rows
            ]

    # ── Health ──

    async def health_check(self) -> bool:
        """Return True if PostgreSQL is reachable."""
        try:
            async with self._engine.connect() as conn:
                await conn.execute(func.now())  # simple query
            return True
        except Exception:
            return False

    # ── Phase 3: Market Intelligence ──

    async def save_market_intel(
        self,
        source: str,
        source_name: str,
        title: str,
        summary: str,
        url: str | None = None,
        published_at: datetime | None = None,
        relevance_score: float = 0.5,
        tags: list | None = None,
        region: str | None = None,
        sector: str | None = None,
        key_points: list | None = None,
        organizations: list | None = None,
        content_hash: str | None = None,
        raw_data: dict | None = None,
    ) -> int | None:
        """Save market intelligence item."""
        async with self.session() as session:
            try:
                intel = MarketIntel(
                    source=source,
                    source_name=source_name,
                    title=title,
                    summary=summary,
                    url=url,
                    published_at=published_at,
                    relevance_score=relevance_score,
                    tags=tags or [],
                    region=region,
                    sector=sector,
                    key_points=key_points or [],
                    organizations=organizations or [],
                    content_hash=content_hash,
                    raw_data=raw_data or {},
                )
                session.add(intel)
                await session.commit()
                await session.refresh(intel)
                return intel.id
            except Exception as e:
                logger.debug("Market intel save failed (may be duplicate): %s", e)
                return None

    async def get_market_intel(
        self,
        hours: int = 24,
        min_relevance: float = 0.0,
        source: str | None = None,
        limit: int = 100,
    ) -> list[dict]:
        """Retrieve recent market intelligence."""
        from datetime import timedelta

        cutoff = datetime.utcnow() - timedelta(hours=hours)

        async with self.session() as session:
            stmt = (
                select(MarketIntel)
                .where(MarketIntel.collected_at > cutoff)
                .where(MarketIntel.relevance_score >= min_relevance)
                .order_by(MarketIntel.relevance_score.desc(), MarketIntel.published_at.desc())
                .limit(limit)
            )
            if source:
                stmt = stmt.where(MarketIntel.source == source)

            result = await session.execute(stmt)
            rows = result.scalars().all()
            return [
                {
                    "id": r.id,
                    "source": r.source,
                    "source_name": r.source_name,
                    "title": r.title,
                    "summary": r.summary,
                    "url": r.url,
                    "published_at": r.published_at.isoformat() if r.published_at else None,
                    "collected_at": r.collected_at.isoformat() if r.collected_at else None,
                    "relevance_score": r.relevance_score,
                    "tags": r.tags or [],
                    "region": r.region,
                    "sector": r.sector,
                    "key_points": r.key_points or [],
                    "organizations": r.organizations or [],
                    "content_hash": r.content_hash,
                }
                for r in rows
            ]

    async def save_morning_brief(
        self,
        brief_id: str,
        brief_date: datetime,
        brief_data: dict,
        delivered: bool = False,
    ) -> int:
        """Save a morning brief record."""
        async with self.session() as session:
            brief = MorningBriefRecord(
                brief_id=brief_id,
                brief_date=brief_date,
                brief_data=brief_data,
                delivered=delivered,
            )
            session.add(brief)
            await session.commit()
            await session.refresh(brief)
            logger.info("Saved morning brief %s", brief_id)
            return brief.id

    async def get_morning_briefs(self, limit: int = 10) -> list[dict]:
        """Retrieve recent morning briefs."""
        async with self.session() as session:
            stmt = (
                select(MorningBriefRecord)
                .order_by(MorningBriefRecord.brief_date.desc())
                .limit(limit)
            )
            result = await session.execute(stmt)
            rows = result.scalars().all()
            return [
                {
                    "id": r.id,
                    "brief_id": r.brief_id,
                    "brief_date": r.brief_date.isoformat() if r.brief_date else None,
                    "brief_data": r.brief_data,
                    "generated_at": r.generated_at.isoformat() if r.generated_at else None,
                    "delivered": r.delivered,
                    "delivery_time": r.delivery_time.isoformat() if r.delivery_time else None,
                }
                for r in rows
            ]

    # ── Phase 3: Meeting Intelligence ──

    async def save_meeting(
        self,
        meeting_id: str,
        title: str,
        meeting_date: datetime,
        participants: list[str],
        duration_minutes: int | None = None,
        meeting_type: str | None = None,
        recall_bot_id: str | None = None,
        recall_transcript_id: str | None = None,
    ) -> int:
        """Save a meeting record."""
        async with self.session() as session:
            meeting = MeetingRecord(
                meeting_id=meeting_id,
                title=title,
                meeting_date=meeting_date,
                participants=participants,
                duration_minutes=duration_minutes,
                meeting_type=meeting_type,
                recall_bot_id=recall_bot_id,
                recall_transcript_id=recall_transcript_id,
            )
            session.add(meeting)
            await session.commit()
            await session.refresh(meeting)
            return meeting.id

    async def save_transcript(
        self,
        meeting_id: str,
        transcript_text: str,
        raw_transcript: dict | None = None,
        speaker_labels: bool = True,
    ) -> int:
        """Save a meeting transcript."""
        async with self.session() as session:
            transcript = MeetingTranscript(
                meeting_id=meeting_id,
                transcript_text=transcript_text,
                raw_transcript=raw_transcript,
                speaker_labels=speaker_labels,
            )
            session.add(transcript)
            await session.commit()
            await session.refresh(transcript)
            return transcript.id

    async def save_decision(
        self,
        meeting_id: str,
        decision: str,
        decision_maker: str | None = None,
        context: str | None = None,
        impact: str | None = None,
    ) -> int:
        """Save a meeting decision."""
        async with self.session() as session:
            rec = MeetingDecision(
                meeting_id=meeting_id,
                decision=decision,
                decision_maker=decision_maker,
                context=context,
                impact=impact,
            )
            session.add(rec)
            await session.commit()
            await session.refresh(rec)
            return rec.id

    async def save_action_item(
        self,
        task: str,
        owner: str,
        meeting_id: str | None = None,
        brief_id: str | None = None,
        due_date: datetime | None = None,
        priority: str = "medium",
        status: str = "pending",
    ) -> int:
        """Save an action item."""
        async with self.session() as session:
            item = ActionItem(
                task=task,
                owner=owner,
                meeting_id=meeting_id,
                brief_id=brief_id,
                due_date=due_date,
                priority=priority,
                status=status,
            )
            session.add(item)
            await session.commit()
            await session.refresh(item)
            return item.id

    async def get_outstanding_actions(self, owner: str | None = None) -> list[dict]:
        """Get outstanding (not complete) action items."""
        async with self.session() as session:
            stmt = select(ActionItem).where(ActionItem.status != "complete").order_by(
                ActionItem.due_date.asc().nulls_last()
            )
            if owner:
                stmt = stmt.where(ActionItem.owner == owner)

            result = await session.execute(stmt)
            rows = result.scalars().all()
            return [
                {
                    "id": r.id,
                    "task": r.task,
                    "owner": r.owner,
                    "meeting_id": r.meeting_id,
                    "brief_id": r.brief_id,
                    "due_date": r.due_date.isoformat() if r.due_date else None,
                    "priority": r.priority,
                    "status": r.status,
                    "created_at": r.created_at.isoformat() if r.created_at else None,
                }
                for r in rows
            ]

    async def get_recent_meetings(self, days: int = 30, limit: int = 50) -> list[dict]:
        """Get recent meetings."""
        from datetime import timedelta

        cutoff = datetime.utcnow() - timedelta(days=days)

        async with self.session() as session:
            stmt = (
                select(MeetingRecord)
                .where(MeetingRecord.meeting_date > cutoff)
                .order_by(MeetingRecord.meeting_date.desc())
                .limit(limit)
            )
            result = await session.execute(stmt)
            rows = result.scalars().all()
            return [
                {
                    "id": r.id,
                    "meeting_id": r.meeting_id,
                    "title": r.title,
                    "meeting_date": r.meeting_date.isoformat() if r.meeting_date else None,
                    "participants": r.participants or [],
                    "duration_minutes": r.duration_minutes,
                    "meeting_type": r.meeting_type,
                    "recall_transcript_id": r.recall_transcript_id,
                }
                for r in rows
            ]
