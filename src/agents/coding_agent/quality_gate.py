"""Quality Gate — integrates Code Review Agent for generated code validation.

All code generated by the Coding Agent MUST pass through the quality gate
before being committed or creating a PR.

This module handles:
- Creating synthetic PRs for review
- Running Code Review Agent on generated code
- Processing feedback and retries
- Approval/rejection logic
"""

from __future__ import annotations

import logging
from tempfile import NamedTemporaryFile
from typing import Any

from src.agents.code_review.agent import code_review_graph, CodeReviewState
from src.agents.coding_agent.models import CodingResult, CodingTask, TaskStatus
from src.config import settings
from src.integrations.github_client import GitHubClient

logger = logging.getLogger(__name__)


class QualityGateResult:
    """Result of the quality gate check."""

    def __init__(
        self,
        passed: bool,
        verdict: str,
        summary: str,
        feedback: str | None = None,
        issues: list[str] | None = None,
    ):
        self.passed = passed
        self.verdict = verdict  # APPROVE, REQUEST_CHANGES, COMMENT
        self.summary = summary
        self.feedback = feedback
        self.issues = issues or []

    def to_dict(self) -> dict[str, Any]:
        return {
            "passed": self.passed,
            "verdict": self.verdict,
            "summary": self.summary,
            "feedback": self.feedback,
            "issues": self.issues,
        }


class QualityGate:
    """Quality gate for validating generated code.

    Integrates with the Code Review Agent to ensure all generated code
    meets quality standards before being merged.
    """

    def __init__(self, github_client: GitHubClient | None = None):
        """Initialize the quality gate.

        Args:
            github_client: GitHub client for creating PRs (optional)
        """
        self.github_client = github_client or GitHubClient()

    async def validate(
        self,
        task: CodingTask,
        result: CodingResult,
        diff: str | None = None,
    ) -> QualityGateResult:
        """Validate generated code through the Code Review Agent.

        Args:
            task: The original coding task
            result: The result from code execution
            diff: Git diff of changes (if available)

        Returns:
            QualityGateResult with validation outcome
        """
        if not result.files_modified:
            return QualityGateResult(
                passed=False,
                verdict="REQUEST_CHANGES",
                summary="No files were modified — coding task produced no changes.",
                feedback=(
                    "The coding agent completed but made zero file changes. "
                    "This usually means the executor failed to run (e.g. Docker "
                    "unavailable, image missing, or Claude Code CLI error). "
                    f"Executor errors: {'; '.join(result.errors) or 'none reported'}"
                ),
                issues=result.errors or ["No files modified by coding agent"],
            )

        logger.info(
            "Running quality gate for task %s: %d files modified",
            task.task_id,
            len(result.files_modified),
        )

        try:
            # Create a synthetic PR review
            review_result = await self._run_code_review(task, result, diff)

            # Process the review result
            verdict = review_result.get("verdict", "COMMENT")
            summary = review_result.get("summary", "")
            comments = review_result.get("comments", [])
            security_issues = review_result.get("security_issues", [])

            # Determine if the code passes the quality gate
            # APPROVE and COMMENT are considered passing
            # REQUEST_CHANGES requires retry
            passed = verdict in ("APPROVE", "COMMENT")

            # Extract feedback
            feedback = self._extract_feedback(summary, comments)

            # Check for critical issues
            if security_issues:
                passed = False
                feedback = f"Security issues found: {', '.join(security_issues)}"

            logger.info(
                "Quality gate %s for task %s: %s",
                "passed" if passed else "failed",
                task.task_id,
                verdict,
            )

            return QualityGateResult(
                passed=passed,
                verdict=verdict,
                summary=summary,
                feedback=feedback,
                issues=comments,
            )

        except Exception as e:
            logger.error("Quality gate failed for task %s: %s", task.task_id, e)
            # Fail closed for safety
            return QualityGateResult(
                passed=False,
                verdict="REQUEST_CHANGES",
                summary=f"Quality gate error: {str(e)}",
                feedback=f"The quality gate encountered an error: {str(e)}",
                issues=[f"Error: {str(e)}"],
            )

    async def _run_code_review(
        self,
        task: CodingTask,
        result: CodingResult,
        diff: str | None = None,
    ) -> dict[str, Any]:
        """Run the Code Review Agent on the generated code.

        Creates a synthetic PR review input and invokes the code review graph.
        """
        # Generate diff if not provided
        if not diff:
            diff = self._generate_synthetic_diff(result)

        # Build a synthetic PR state
        review_input: CodeReviewState = {
            "repository": task.repository,
            "pr_number": task.related_pr or 0,
            "pr_title": f"[Coding Agent] {task.description[:50]}",
            "pr_body": (
                f"**Auto-generated by Coding Agent**\n\n"
                f"Task ID: {task.task_id}\n"
                f"Description: {task.description}\n\n"
                f"This is a synthetic review for quality validation."
            ),
            "pr_author": "coding-agent",
            "base_branch": task.base_branch,
            "head_branch": task.branch_name or f"coding-agent/{task.task_id[:12]}",
            "diff": diff,
            "changed_files": [
                {
                    "filename": f.path,
                    "status": f.status,
                    "additions": f.additions,
                    "deletions": f.deletions,
                }
                for f in result.files_modified
            ],
            "file_contexts": {},
            "review_result": None,
            "posted": False,
            "error": None,
        }

        # Invoke the code review graph
        try:
            review_output = await code_review_graph.ainvoke(review_input)
        except Exception as e:
            logger.error("Code review graph failed: %s", e)
            raise RuntimeError(f"Code review graph invocation failed: {e}")

        if review_output.get("review_result"):
            return review_output["review_result"]
        elif review_output.get("error"):
            raise RuntimeError(review_output["error"])
        else:
            return {
                "verdict": "COMMENT",
                "summary": "Review completed with no specific feedback.",
                "comments": [],
                "security_issues": [],
            }

    def _generate_synthetic_diff(self, result: CodingResult) -> str:
        """Generate a synthetic diff from the file changes."""
        diff_lines = []

        for change in result.files_modified:
            diff_lines.append(f"--- a/{change.path}")
            diff_lines.append(f"+++ b/{change.path}")
            diff_lines.append(f"@@ -0,0 +1,{change.additions} @@")
            diff_lines.append("+ [Auto-generated code]")

        return "\n".join(diff_lines)

    def _extract_feedback(self, summary: str, comments: list[dict]) -> str:
        """Extract actionable feedback from the review."""
        feedback_parts = [summary]

        if comments:
            feedback_parts.append("\n**Specific Comments:**")
            for comment in comments[:5]:  # Limit to 5 comments
                body = comment.get("body", "")
                if body:
                    feedback_parts.append(f"- {body[:100]}")

        return "\n".join(feedback_parts)

    async def create_pr_if_approved(
        self,
        task: CodingTask,
        result: CodingResult,
        gate_result: QualityGateResult,
    ) -> dict[str, Any]:
        """Create a PR if the quality gate passed.

        Args:
            task: Original coding task
            result: Execution result
            gate_result: Quality gate validation result

        Returns:
            PR creation result
        """
        if not gate_result.passed:
            return {
                "success": False,
                "reason": "Quality gate did not pass",
            }

        if not task.branch_name:
            return {
                "success": False,
                "reason": "No branch name specified for PR",
            }

        try:
            # Create PR using GitHub client
            pr = await self._create_github_pr(
                repository=task.repository,
                title=f"[Coding Agent] {task.description}",
                body=self._format_pr_body(task, result, gate_result),
                head=task.branch_name,
                base=task.base_branch,
            )

            logger.info("Created PR #%d for task %s", pr.get("number"), task.task_id)

            return {
                "success": True,
                "pr_number": pr.get("number"),
                "pr_url": pr.get("html_url"),
            }

        except Exception as e:
            logger.error("Failed to create PR for task %s: %s", task.task_id, e)
            return {
                "success": False,
                "reason": str(e),
            }

    async def _create_github_pr(
        self,
        repository: str,
        title: str,
        body: str,
        head: str,
        base: str,
    ) -> dict[str, Any]:
        """Create a PR via GitHub API."""
        try:
            result = self.github_client.create_pull_request(
                repo_full_name=repository,
                title=title,
                body=body,
                head=head,
                base=base,
                draft=False,  # Create real PR, not draft
            )

            logger.info("Created PR #%s for approved code", result.get("number"))
            return result

        except Exception as e:
            logger.error("Failed to create PR: %s", e)
            raise

    def _format_pr_body(
        self,
        task: CodingTask,
        result: CodingResult,
        gate_result: QualityGateResult,
    ) -> str:
        """Format the PR description."""
        lines = [
            f"## Auto-generated PR from Coding Agent",
            f"",
            f"**Task ID:** {task.task_id}",
            f"**Agent:** {result.agent_used.value}",
            f"**Execution Time:** {result.execution_time_seconds:.1f}s",
            f"",
            f"### Description",
            f"{task.description}",
            f"",
            f"### Changes",
        ]

        for change in result.files_modified:
            lines.append(f"- `{change.path}` ({change.status})")

        lines.extend([
            f"",
            f"### Quality Gate",
            f"- **Status:** {'✅ Passed' if gate_result.passed else '❌ Failed'}",
            f"- **Verdict:** {gate_result.verdict}",
            f"",
            gate_result.summary or "No summary provided.",
        ])

        if gate_result.feedback:
            lines.extend([
                f"",
                f"### Feedback",
                gate_result.feedback,
            ])

        return "\n".join(lines)
